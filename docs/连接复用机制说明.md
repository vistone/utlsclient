# uTLS 客户端连接复用机制说明

## 连接复用的多层架构

### 1. HTTP 客户端级别复用（第一层）

```go
// 按 host 缓存 HTTP 客户端
h2Clients map[string]*http.Client  // HTTP/2 客户端缓存
h1Clients map[string]*http.Client  // HTTP/1.1 客户端缓存
```

- **机制**：同一个 host 的所有请求都使用同一个 HTTP 客户端实例
- **优势**：避免重复创建客户端，复用 Transport 连接池
- **缓存键**：使用 host 作为 key

### 2. Transport 连接池级别复用（第二层）

#### HTTP/1.1 连接池配置

```go
MaxIdleConns:          100,              // 全局最大空闲连接数：100
MaxIdleConnsPerHost:   10,               // 每个 host 最大空闲连接数：10
IdleConnTimeout:       60 * time.Second, // 空闲连接超时：60秒后自动关闭
DisableKeepAlives:     false,            // 启用 Keep-Alive 长连接
```

- **Keep-Alive**：同一个 host 的多个请求会复用同一个 TCP/TLS 连接
- **连接池**：最多为每个 host 保留 10 个空闲连接
- **自动清理**：空闲连接超过 60 秒后自动关闭

#### HTTP/2 连接复用

```go
ReadIdleTimeout:  30 * time.Second,  // 读取空闲超时
PingTimeout:      15 * time.Second,   // Ping 超时
```

- **多路复用**：HTTP/2 本身就支持在单个连接上并发传输多个请求
- **连接保持**：通过 Ping 机制保持连接活跃

### 3. 连接复用的工作流程

```
请求1: https://www.google.com/ → 创建连接 A → 使用连接 A
请求2: https://www.google.com/ → 复用连接 A（如果仍空闲）→ 使用连接 A
请求3: https://www.google.com/ → 复用连接 A → 使用连接 A
...
空闲 60 秒后 → 连接 A 关闭
请求4: https://www.google.com/ → 创建新连接 B → 使用连接 B
```

## 连接复用示例

### 场景 1：同一 host 的多次请求

```go
client := utls_client.NewClient(nil, nil)

// 第一次请求：创建连接
resp1, _ := client.Get("https://www.google.com/", nil)

// 第二次请求：复用连接（如果仍在空闲时间内）
resp2, _ := client.Get("https://www.google.com/search", nil)

// 第三次请求：复用连接
resp3, _ := client.Get("https://www.google.com/images", nil)
```

**结果**：后两次请求会复用第一次建立的连接，避免重复的 TLS 握手。

### 场景 2：不同 host 的请求

```go
// 不同的 host 会使用不同的客户端和连接
client.Get("https://www.google.com/", nil)    // 使用连接池 A
client.Get("https://www.github.com/", nil)    // 使用连接池 B
client.Get("https://www.google.com/search", nil) // 复用连接池 A
```

## 连接复用配置说明

### 当前配置参数

| 参数 | 值 | 说明 |
|------|-----|------|
| `MaxIdleConns` | 100 | 全局最多保留 100 个空闲连接 |
| `MaxIdleConnsPerHost` | 10 | 每个 host 最多保留 10 个空闲连接 |
| `IdleConnTimeout` | 60秒 | 空闲连接超过 60 秒后关闭 |
| `DisableKeepAlives` | false | 启用 Keep-Alive（长连接） |

### 优化建议

如果需要更高性能，可以调整：

```go
config := &utls_client.Config{
    Timeout: 30 * time.Second,
}
client := utls_client.NewClient(nil, config)

// 可以通过修改 Transport 来调整连接池
// （需要在 buildHTTP1Client 中修改）
```

## 连接复用的优势

1. **减少 TLS 握手开销**：复用已建立的 TLS 连接，避免重复握手
2. **降低延迟**：复用连接比新建连接快得多
3. **提高吞吐量**：HTTP/2 多路复用可以在单个连接上并发处理多个请求
4. **资源优化**：合理的连接池大小平衡了性能和资源消耗

## 注意事项

1. **空闲连接会自动关闭**：60 秒无活动后，连接会被关闭
2. **每个 host 最多 10 个空闲连接**：超过后，旧的连接会被关闭
3. **HTTP/2 优先**：优先尝试 HTTP/2，失败后回退到 HTTP/1.1
4. **线程安全**：连接池管理是线程安全的（使用 mutex 保护）

## 总结

✅ **是的，lib.go 实现了完整的长连接复用机制**：
- HTTP 客户端级别：按 host 缓存客户端
- Transport 级别：HTTP/1.1 使用连接池 + Keep-Alive，HTTP/2 使用多路复用
- 自动管理：空闲连接自动清理，保持连接池健康

这确保了在频繁访问同一 host 时，连接会被有效复用，大大提升了性能。


