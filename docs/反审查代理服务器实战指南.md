# 反审查代理服务器实战指南

## 目录
1. [整体架构设计](#整体架构设计)
2. [环境准备](#环境准备)
3. [代理服务器实现](#代理服务器实现)
4. [客户端实现](#客户端实现)
5. [部署和配置](#部署和配置)
6. [测试验证](#测试验证)
7. [高级优化](#高级优化)
8. [故障排查](#故障排查)
9. [安全注意事项](#安全注意事项)

---

## 整体架构设计

### 技术栈组合

将 uTLS、uQUIC 和 TapDance 组合使用，构建多层反审查系统：

```
客户端 -> TapDance/uQUIC -> uTLS -> 代理服务器 -> 目标服务器
```

**分层作用**：
1. **TapDance**：隐蔽通信，流量伪装
2. **uQUIC**：QUIC 层指纹对抗（HTTP/3）
3. **uTLS**：TLS 层指纹对抗（TLS/HTTPS）

### 架构模式

#### 模式 1：纯 uTLS 代理（适用于 HTTPS）

```
客户端 -> uTLS(Chrome指纹) -> 代理服务器 -> 目标网站
```

#### 模式 2：uQUIC + uTLS 代理（适用于 HTTP/3）

```
客户端 -> uQUIC(Firefox指纹) + uTLS(Firefox指纹) -> 代理服务器 -> 目标网站
```

#### 模式 3：TapDance 隐蔽通道（最隐蔽）

```
客户端 -> TapDance -> Station -> 目标网站
```

#### 模式 4：混合模式（推荐）

```
客户端 -> uTLS/uQUIC -> SOCKS/HTTP代理 -> TapDance -> Station -> 目标网站
```

---

## 环境准备

### 1. 安装依赖

```bash
# 创建项目目录
mkdir anti-censorship-proxy
cd anti-censorship-proxy

# 初始化 Go 模块
go mod init anti-censorship-proxy

# 安装依赖
go get github.com/refraction-networking/utls@v1.8.1
go get github.com/refraction-networking/uquic@v0.0.6
go get github.com/refraction-networking/gotapdance/tapdance@v1.7.10
go get github.com/refraction-networking/uquic/http3

# 安装其他必要依赖
go get -u golang.org/x/net/proxy
go get -u github.com/elazarl/goproxy
```

### 2. 目录结构

```
anti-censorship-proxy/
├── main.go              # 主程序
├── server.go            # 代理服务器
├── client.go            # 客户端
├── tapdance/
│   └── assets/          # TapDance 资源文件
│       ├── ClientConf
│       └── roots
├── config.json          # 配置文件
├── go.mod
└── README.md
```

---

## 代理服务器实现

### 完整的代理服务器代码

```go
package main

import (
    "bufio"
    "crypto/tls"
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net"
    "net/http"
    "sync"
    "time"

    "github.com/elazarl/goproxy"
    utls "github.com/refraction-networking/utls"
    "golang.org/x/net/proxy"
)

// 配置结构
type Config struct {
    ServerAddr        string   `json:"server_addr"`
    Port              int      `json:"port"`
    TLSFingerprint    string   `json:"tls_fingerprint"`
    EnableQUIC        bool     `json:"enable_quic"`
    QUICFingerprint   string   `json:"quic_fingerprint"`
    EnableTapDance    bool     `json:"enable_tapdance"`
    LogLevel          string   `json:"log_level"`
}

var cfg Config

// 加载配置
func loadConfig(filename string) error {
    data, err := ioutil.ReadFile(filename)
    if err != nil {
        return fmt.Errorf("读取配置失败: %w", err)
    }
    return json.Unmarshal(data, &cfg)
}

// uTLS RoundTripper（支持多种浏览器指纹）
func createUTLSRoundTripper(fingerprint string) http.RoundTripper {
    var helloID utls.ClientHelloID
    
    switch fingerprint {
    case "chrome":
        helloID = utls.HelloChrome_Auto
    case "firefox":
        helloID = utls.HelloFirefox_Auto
    case "safari":
        helloID = utls.HelloSafari_Auto
    case "edge":
        helloID = utls.HelloEdge_Auto
    case "random":
        helloID = utls.HelloRandomized
    default:
        helloID = utls.HelloFirefox_Auto  // 默认使用 Firefox
    }

    return &http.Transport{
        TLSClientConfig: &utls.Config{
            MinVersion:         utls.VersionTLS12,
            MaxVersion:         utls.VersionTLS13,
            InsecureSkipVerify: false,  // 生产环境设为 false
        },
        DialTLS: func(network, addr string) (net.Conn, error) {
            conn, err := net.Dial(network, addr)
            if err != nil {
                return nil, err
            }
            
            config := &utls.Config{
                ServerName:         addr,
                InsecureSkipVerify: false,
            }
            
            uconn := utls.UClient(conn, config, helloID)
            err = uconn.Handshake()
            if err != nil {
                conn.Close()
                return nil, err
            }
            
            return uconn, nil
        },
        MaxIdleConns:          100,
        MaxIdleConnsPerHost:   10,
        IdleConnTimeout:       90 * time.Second,
    }
}

// HTTP 代理服务器
func startHTTPProxy() {
    proxy := goproxy.NewProxyHttpServer()
    
    // 详细日志
    if cfg.LogLevel == "debug" {
        proxy.Verbose = true
    }

    // 设置连接超时
    proxy.ConnectDial = func(network string, addr string) (net.Conn, error) {
        timeout, _ := time.ParseDuration("30s")
        return net.DialTimeout(network, addr, timeout)
    }

    // 请求处理
    proxy.OnRequest().DoFunc(func(r *http.Request, ctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {
        log.Printf("[请求] %s %s", r.Method, r.URL.String())
        return r, nil
    })

    // 响应处理
    proxy.OnResponse().DoFunc(func(r *http.Response, ctx *goproxy.ProxyCtx) *http.Response {
        log.Printf("[响应] %s (状态码: %d)", ctx.Req.URL.String(), r.StatusCode)
        return r
    })

    // 启动服务器
    addr := fmt.Sprintf(":%d", cfg.Port)
    log.Printf("[代理服务器] 监听地址: %s", addr)
    log.Fatal(http.ListenAndServe(addr, proxy))
}

// SOCKS5 代理服务器
func startSOCKS5Proxy() {
    addr := fmt.Sprintf(":%d", cfg.Port)
    listener, err := net.Listen("tcp", addr)
    if err != nil {
        log.Fatalf("监听失败: %v", err)
    }
    log.Printf("[SOCKS5] 监听地址: %s", addr)

    transport := createUTLSRoundTripper(cfg.TLSFingerprint)

    for {
        client, err := listener.Accept()
        if err != nil {
            log.Printf("接受连接失败: %v", err)
            continue
        }
        
        go handleSOCKS5(client, transport)
    }
}

// 处理 SOCKS5 连接
func handleSOCKS5(client net.Conn, transport http.RoundTripper) {
    defer client.Close()
    
    // SOCKS5 握手
    if !socks5Handshake(client) {
        return
    }

    // 读取请求
    target, err := socks5ReadRequest(client)
    if err != nil {
        log.Printf("读取请求失败: %v", err)
        return
    }

    // 连接到目标
    server, err := connectToTarget(target, transport)
    if err != nil {
        log.Printf("连接目标失败: %v", err)
        return
    }
    defer server.Close()

    // 转发数据
    var wg sync.WaitGroup
    wg.Add(2)
    
    go func() {
        defer wg.Done()
        io.Copy(server, client)
    }()
    
    go func() {
        defer wg.Done()
        io.Copy(client, server)
    }()
    
    wg.Wait()
}

// SOCKS5 握手
func socks5Handshake(conn net.Conn) bool {
    buf := make([]byte, 2)
    if _, err := conn.Read(buf); err != nil {
        return false
    }
    if buf[0] != 0x05 {
        return false
    }
    
    // 发送响应：无需认证
    conn.Write([]byte{0x05, 0x00})
    return true
}

// 读取 SOCKS5 请求
func socks5ReadRequest(conn net.Conn) (string, error) {
    buf := make([]byte, 256)
    n, err := conn.Read(buf)
    if err != nil {
        return "", err
    }
    
    // 解析目标地址
    if buf[1] != 0x01 {  // 仅支持 CONNECT
        return "", fmt.Errorf("不支持的命令")
    }
    
    addr := ""
    switch buf[3] {
    case 0x01:  // IPv4
        addr = fmt.Sprintf("%d.%d.%d.%d:%d",
            buf[4], buf[5], buf[6], buf[7],
            int(buf[8])<<8|int(buf[9]))
    case 0x03:  // 域名
        domain := string(buf[5 : 5+buf[4]])
        port := int(buf[5+buf[4]])<<8 | int(buf[6+buf[4]])
        addr = fmt.Sprintf("%s:%d", domain, port)
    default:
        return "", fmt.Errorf("不支持的地址类型")
    }
    
    // 发送成功响应
    conn.Write([]byte{0x05, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 0})
    
    return addr, nil
}

// 连接到目标服务器
func connectToTarget(target string, transport http.RoundTripper) (net.Conn, error) {
    // 这里可以根据配置选择不同的连接方式
    // 1. 直接连接
    // 2. 通过 TapDance
    // 3. 通过 uQUIC
    
    // 简化实现：直接连接
    return net.Dial("tcp", target)
}

func main() {
    // 加载配置
    if err := loadConfig("config.json"); err != nil {
        log.Fatalf("加载配置失败: %v", err)
    }

    // 选择启动模式
    if cfg.EnableTapDance {
        log.Println("使用 TapDance 模式")
        // 启动 TapDance 服务器
        // ...
    } else if cfg.EnableQUIC {
        log.Println("使用 uQUIC 模式")
        // 启动 uQUIC 服务器
        // ...
    } else {
        log.Println("使用标准 HTTP 代理")
        startHTTPProxy()
    }
}
```

---

## 客户端实现

### 高级客户端代码

```go
package main

import (
    "bytes"
    "context"
    "crypto/tls"
    "fmt"
    "io"
    "log"
    "net"
    "net/http"
    "net/url"
    "sync"
    "time"

    utls "github.com/refraction-networking/utls"
    "github.com/refraction-networking/uquic"
    "github.com/refraction-networking/uquic/http3"
    "github.com/refraction-networking/gotapdance/tapdance"
)

// 客户端管理器
type ProxyClient struct {
    transport      http.RoundTripper
    quicTransport  *http3.RoundTripper
    tapdanceConn   tapdance.Conn
    mu             sync.RWMutex
}

// 创建代理客户端
func NewProxyClient(cfg Config) (*ProxyClient, error) {
    client := &ProxyClient{}

    // 根据配置选择传输方式
    if cfg.UseQUIC {
        if err := client.initQUIC(cfg); err != nil {
            return nil, fmt.Errorf("初始化 uQUIC 失败: %w", err)
        }
    } else if cfg.UseTapDance {
        if err := client.initTapDance(cfg); err != nil {
            return nil, fmt.Errorf("初始化 TapDance 失败: %w", err)
        }
    } else {
        if err := client.initUTLS(cfg); err != nil {
            return nil, fmt.Errorf("初始化 uTLS 失败: %w", err)
        }
    }

    return client, nil
}

// 初始化 uTLS
func (c *ProxyClient) initUTLS(cfg Config) error {
    var helloID utls.ClientHelloID
    
    switch cfg.Fingerprint {
    case "chrome":
        helloID = utls.HelloChrome_133
    case "firefox":
        helloID = utls.HelloFirefox_Auto
    case "random":
        helloID = utls.HelloRandomized
    default:
        helloID = utls.HelloFirefox_Auto
    }

    c.transport = &http.Transport{
        TLSClientConfig: &tls.Config{
            MinVersion:         tls.VersionTLS12,
            MaxVersion:         tls.VersionTLS13,
        },
        DialTLS: func(network, addr string) (net.Conn, error) {
            conn, err := net.DialTimeout(network, addr, 30*time.Second)
            if err != nil {
                return nil, err
            }
            
            host, _, _ := net.SplitHostPort(addr)
            config := &utls.Config{
                ServerName:         host,
                InsecureSkipVerify: false,
                MinVersion:         utls.VersionTLS12,
                MaxVersion:         utls.VersionTLS13,
            }
            
            uconn := utls.UClient(conn, config, helloID)
            if err := uconn.Handshake(); err != nil {
                conn.Close()
                return nil, err
            }
            
            return uconn, nil
        },
        MaxIdleConns:        100,
        MaxIdleConnsPerHost: 10,
        IdleConnTimeout:     90 * time.Second,
        DisableCompression:  true,
        DisableKeepAlives:   false,
    }

    return nil
}

// 初始化 uQUIC
func (c *ProxyClient) initQUIC(cfg Config) error {
    roundTripper := &http3.RoundTripper{
        TLSClientConfig: &tls.Config{},
        QuicConfig:      &uquic.Config{},
    }

    var quicID uquic.QUICID
    switch cfg.QUICFingerprint {
    case "chrome":
        quicID = uquic.QUICChrome_115
    case "firefox":
        quicID = uquic.QUICFirefox_116
    default:
        quicID = uquic.QUICFirefox_116
    }

    quicSpec, err := uquic.QUICID2Spec(quicID)
    if err != nil {
        return err
    }

    c.quicTransport = http3.GetURoundTripper(
        roundTripper,
        &quicSpec,
        nil,
    )

    return nil
}

// 初始化 TapDance
func (c *ProxyClient) initTapDance(cfg Config) error {
    tapdance.AssetsSetDir(cfg.TapDanceAssetsDir)
    return nil
}

// 发送 HTTP 请求
func (c *ProxyClient) DoRequest(ctx context.Context, method, url string, headers map[string]string, body []byte) (*http.Response, error) {
    c.mu.RLock()
    transport := c.transport
    c.mu.RUnlock()

    var req *http.Request
    var err error

    if body != nil {
        req, err = http.NewRequestWithContext(ctx, method, url, bytes.NewReader(body))
    } else {
        req, err = http.NewRequestWithContext(ctx, method, url, nil)
    }

    if err != nil {
        return nil, err
    }

    // 设置头部
    for k, v := range headers {
        req.Header.Set(k, v)
    }

    // 使用指定的 User-Agent
    if req.Header.Get("User-Agent") == "" {
        req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
    }

    client := &http.Client{
        Transport: transport,
        Timeout:   30 * time.Second,
    }

    return client.Do(req)
}

// 测试连接
func (c *ProxyClient) TestConnection(testURL string) error {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    resp, err := c.DoRequest(ctx, "GET", testURL, nil, nil)
    if err != nil {
        return fmt.Errorf("连接测试失败: %w", err)
    }
    defer resp.Body.Close()

    log.Printf("测试成功: %s (状态码: %d)", testURL, resp.StatusCode)
    return nil
}

func main() {
    // 配置
    cfg := Config{
        Fingerprint:  "firefox",  // 使用 Firefox 指纹
        ProxyURL:     "127.0.0.1:8080",
        UseQUIC:      false,
        UseTapDance:  false,
    }

    // 创建客户端
    client, err := NewProxyClient(cfg)
    if err != nil {
        log.Fatalf("创建客户端失败: %v", err)
    }

    // 测试连接
    testURL := "https://www.google.com"
    if err := client.TestConnection(testURL); err != nil {
        log.Printf("连接测试失败: %v", err)
    }
}
```

---

## 配置文件示例

### config.json

```json
{
  "server_addr": "0.0.0.0",
  "port": 8080,
  "tls_fingerprint": "firefox",
  "enable_quic": false,
  "quic_fingerprint": "firefox",
  "enable_tapdance": false,
  "log_level": "info",
  "fingerprints": {
    "chrome": {
      "enabled": true,
      "tls": "chrome_133",
      "quic": "chrome_115"
    },
    "firefox": {
      "enabled": true,
      "tls": "firefox_auto",
      "quic": "firefox_116"
    },
    "safari": {
      "enabled": false,
      "tls": "safari_auto",
      "quic": ""
    },
    "random": {
      "enabled": true,
      "tls": "randomized",
      "quic": "randomized"
    }
  },
  "proxy": {
    "type": "http",
    "timeout": "30s",
    "keep_alive": true
  },
  "security": {
    "verify_tls": true,
    "allow_insecure": false
  }
}
```

---

## 实战部署代码

### 完整的主程序

```go
package main

import (
    "crypto/tls"
    "encoding/json"
    "flag"
    "io/ioutil"
    "log"
    "net/http"
    "sync"
    "time"

    utls "github.com/refraction-networking/utls"
    "github.com/elazarl/goproxy"
)

type Config struct {
    Mode       string `json:"mode"`
    Port       int    `json:"port"`
    Fingerprint string `json:"fingerprint"`
}

var config Config

func main() {
    cfgFile := flag.String("config", "config.json", "配置文件")
    mode := flag.String("mode", "http", "模式: http, socks5, quic, tapdance")
    port := flag.Int("port", 8080, "端口")
    fingerprint := flag.String("fingerprint", "firefox", "指纹: firefox, chrome, safari, random")
    
    flag.Parse()

    // 加载配置
    if data, err := ioutil.ReadFile(*cfgFile); err == nil {
        json.Unmarshal(data, &config)
    }

    // 命令行参数覆盖配置文件
    if *mode != "http" {
        config.Mode = *mode
    }
    if *port != 8080 {
        config.Port = *port
    }
    if *fingerprint != "firefox" {
        config.Fingerprint = *fingerprint
    }

    log.Printf("启动反审查代理服务器")
    log.Printf("模式: %s, 端口: %d, 指纹: %s", config.Mode, config.Port, config.Fingerprint)

    switch config.Mode {
    case "http":
        startHTTPProxy()
    case "socks5":
        startSOCKS5Proxy()
    default:
        startHTTPProxy()
    }
}

func startHTTPProxy() {
    proxy := goproxy.NewProxyHttpServer()
    proxy.Verbose = true

    // 设置 uTLS Transport
    transport := createUTLSTransport(config.Fingerprint)
    proxy.Tr = transport

    // 连接处理
    proxy.OnRequest().HandleConnect(goproxy.FuncConnectHandler(func(host string, ctx *goproxy.ProxyCtx) (*goproxy.ConnectAction, string) {
        log.Printf("[连接] %s", host)
        return goproxy.OkConnect, host
    }))

    log.Printf("HTTP 代理启动: :%d", config.Port)
    log.Fatal(http.ListenAndServe(":"+string(config.Port), proxy))
}

func createUTLSTransport(fingerprint string) *http.Transport {
    var helloID utls.ClientHelloID
    
    switch fingerprint {
    case "chrome":
        helloID = utls.HelloChrome_133
    case "firefox":
        helloID = utls.HelloFirefox_Auto
    case "safari":
        helloID = utls.HelloSafari_Auto
    case "random":
        helloID = utls.HelloRandomized
    default:
        helloID = utls.HelloFirefox_Auto
    }

    return &http.Transport{
        TLSClientConfig: &tls.Config{
            MinVersion: tls.VersionTLS12,
            MaxVersion: tls.VersionTLS13,
        },
        DialTLS: func(network, addr string) (net.Conn, error) {
            conn, err := net.DialTimeout(network, addr, 30*time.Second)
            if err != nil {
                return nil, err
            }

            host, _, _ := net.SplitHostPort(addr)
            config := &utls.Config{
                ServerName:         host,
                InsecureSkipVerify: false,
            }

            uconn := utls.UClient(conn, config, helloID)
            if err := uconn.Handshake(); err != nil {
                conn.Close()
                return nil, err
            }

            return uconn, nil
        },
        MaxIdleConns:        100,
        MaxIdleConnsPerHost: 10,
        IdleConnTimeout:     90 * time.Second,
    }
}
```

---

## 部署步骤

### 1. 编译程序

```bash
# 编译
go build -o anti-censorship-proxy

# 或交叉编译
GOOS=linux GOARCH=amd64 go build -o anti-censorship-proxy
```

### 2. 创建配置文件

```bash
cat > config.json << 'EOF'
{
  "mode": "http",
  "port": 8080,
  "fingerprint": "firefox"
}
EOF
```

### 3. 运行

```bash
# 基础运行
./anti-censorship-proxy

# 指定配置
./anti-censorship-proxy -config=config.json -port=8080 -fingerprint=firefox

# 使用 Chrome 指纹
./anti-censorship-proxy -fingerprint=chrome

# 使用随机指纹
./anti-censorship-proxy -fingerprint=random
```

### 4. 客户端配置

**浏览器配置**：
```
代理类型: HTTP
服务器: 127.0.0.1
端口: 8080
```

**curl 命令**：
```bash
curl -x http://127.0.0.1:8080 https://www.google.com
```

---

## 测试验证

### 指纹测试

```bash
# 测试 TLS 指纹
curl -x http://127.0.0.1:8080 https://tls.browserleaks.com/json

# 测试 IP 泄露
curl -x http://127.0.0.1:8080 https://api.ipify.org

# 测试 WebRTC
# 使用浏览器访问 https://browserleaks.com/webrtc
```

### 连接测试

```go
package main

import (
    "fmt"
    "io"
    "net/http"
)

func testProxy(proxyURL, testURL string) error {
    client := &http.Client{
        Transport: &http.Transport{
            Proxy: http.ProxyURL(proxyURL),
        },
        Timeout: 30 * time.Second,
    }

    resp, err := client.Get(testURL)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    body, _ := io.ReadAll(resp.Body)
    fmt.Printf("状态码: %d, 长度: %d\n", resp.StatusCode, len(body))
    return nil
}

func main() {
    proxyURL, _ := http.NewURL("http://127.0.0.1:8080")
    
    testURLs := []string{
        "https://www.google.com",
        "https://www.github.com",
        "https://www.reddit.com",
    }

    for _, url := range testURLs {
        if err := testProxy(proxyURL, url); err != nil {
            fmt.Printf("测试失败: %s\n", err)
        }
    }
}
```

---

## 高级优化

### 1. 多指纹轮换

```go
type FingerprintRotator struct {
    fingerprints []utls.ClientHelloID
    current      int
    mu           sync.Mutex
}

func (r *FingerprintRotator) GetNext() utls.ClientHelloID {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    id := r.fingerprints[r.current]
    r.current = (r.current + 1) % len(r.fingerprints)
    return id
}
```

### 2. 智能重试

```go
func connectWithRetry(target string, maxRetries int) error {
    for i := 0; i < maxRetries; i++ {
        if err := connect(target); err == nil {
            return nil
        }
        time.Sleep(time.Duration(i+1) * time.Second)
    }
    return fmt.Errorf("重试 %d 次后仍失败", maxRetries)
}
```

### 3. 流量分流

```go
func routeTraffic(domain string) string {
    if isBlocked(domain) {
        return "tapdance"  // 使用 TapDance
    } else if supportsQUIC(domain) {
        return "quic"      // 使用 uQUIC
    }
    return "tls"           // 使用 uTLS
}
```

---

## 故障排查

### 常见问题

**1. 连接失败**
```go
// 启用详细日志
log.SetLevel(log.DebugLevel)

// 检查网络
net.DialTimeout("tcp", "target.com:443", 10*time.Second)
```

**2. TLS 握手失败**
```go
// 尝试不同指纹
fingerprints := []utls.ClientHelloID{
    utls.HelloFirefox_Auto,
    utls.HelloChrome_133,
    utls.HelloRandomized,
}
```

**3. 指纹被检测**
- 切换指纹类型
- 使用随机指纹
- 启用 TapDance 隐蔽通道

---

## 安全注意事项

### ⚠️ 重要安全提示

1. **不要跳过 TLS 验证**（生产环境）
2. **定期更新指纹**
3. **使用最新的库版本**
4. **保护配置文件**
5. **监控异常流量**

### 最佳实践

- 使用环境变量存储敏感配置
- 启用日志审计
- 实现访问控制
- 定期安全扫描

---

## 完整项目结构

```
anti-censorship-proxy/
├── cmd/
│   ├── server/
│   │   └── main.go
│   └── client/
│       └── main.go
├── internal/
│   ├── utls/
│   │   └── transport.go
│   ├── uquic/
│   │   └── transport.go
│   └── tapdance/
│       └── client.go
├── pkg/
│   ├── config/
│   │   └── config.go
│   └── proxy/
│       └── proxy.go
├── assets/
│   └── tapdance/
│       ├── ClientConf
│       └── roots
├── configs/
│   ├── dev.json
│   └── prod.json
├── go.mod
├── go.sum
├── Makefile
└── README.md
```

---

**最后更新：** 2025-01-10  
**版本：** 1.0.0  
**说明：** 实战级反审查代理服务器实现方案
