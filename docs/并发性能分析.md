# 并发性能分析

## 当前实现分析

### 应用层并发
- **无并发限制**：647个IP同时启动647个goroutine，全并发执行
- **每个IP使用独立客户端**：每个goroutine创建一个新的`Client`实例
- **每个IP建立独立连接**：由于使用不同IP地址，每个请求都是新的TCP连接

### 连接复用机制

#### HTTP/1.1 连接池设置
```go
MaxIdleConns:          100,              // 全局最多 100 个空闲连接
MaxIdleConnsPerHost:   10,               // 每个 host 最多 10 个空闲连接
IdleConnTimeout:       60 * time.Second, // 空闲 60 秒后关闭
DisableKeepAlives:     false,            // 启用 Keep-Alive
```

**重要**：这些限制主要影响**连接复用**，对新建连接影响较小。

### 导致慢的原因分析

#### 1. **系统资源限制** ⚠️（最可能）
- **文件描述符限制**：647个并发连接需要至少647个文件描述符
- **检查方法**：`ulimit -n` 查看当前限制
- **如果限制不足**：连接会排队等待，导致延迟累积

#### 2. **TCP连接建立时间**
- **每个IP都是新连接**：需要TCP三次握手 + TLS握手
- **TLS握手时间**：通常 100-300ms，取决于网络延迟
- **累积效应**：如果系统资源受限，后面的连接需要等待前面的完成

#### 3. **网络路径差异**
- **不同IP的物理位置不同**：导致RTT（往返时间）差异
- **路由器拥塞**：某些网络路径可能更拥堵
- **服务器负载**：不同IP对应的服务器负载可能不同

#### 4. **HTTP Transport 的限制**
- **MaxIdleConnsPerHost: 10**：虽然每个IP不同，但如果使用域名解析，可能会有DNS缓存
- **实际影响较小**：因为每个IP都是直接连接，不经过DNS解析

### 性能瓶颈判断

**如果是因为并发控制导致排队：**
- ✅ 前几个请求会很快完成（系统资源充足时）
- ❌ 后面请求会逐渐变慢（资源耗尽后排队）
- 📊 耗时应该呈现**阶梯式增长**

**如果是因为线路拥堵：**
- ✅ 不同IP的延迟差异较大（地理距离导致）
- ❌ 某些国家/城市的IP整体较慢
- 📊 耗时应该按**地理位置分组**，同地区IP延迟相近

### 优化建议

#### 方案1：增加文件描述符限制（推荐）
```bash
# 临时增加（当前会话）
ulimit -n 2048

# 永久增加（需要修改系统配置）
# /etc/security/limits.conf
```

#### 方案2：分批并发（避免系统资源耗尽）
```go
const batchSize = 100  // 每批100个
for i := 0; i < len(allIPs); i += batchSize {
    // 启动一批请求
    // 等待部分完成后再启动下一批
}
```

#### 方案3：调整连接池设置
```go
MaxIdleConns:          1000,  // 增加全局连接数
MaxIdleConnsPerHost:   100,   // 增加每host连接数
```

### 诊断方法

1. **检查文件描述符使用情况**
```bash
# 运行程序时监控
watch -n 1 'lsof -p $(pgrep test_earth) | wc -l'
```

2. **查看连接建立时间分布**
- 如果前100个很快，后面变慢 → 可能是系统资源限制
- 如果按地理位置分组慢 → 可能是网络线路问题

3. **分析耗时分布**
- 统计前1/3、中1/3、后1/3的请求平均耗时
- 如果后1/3明显慢 → 可能是排队问题
- 如果延迟差异随机 → 可能是线路问题

## 结论

**从您的数据看（最后请求耗时7秒多）：**

最可能的原因是：
1. **系统资源限制（文件描述符）**：647个并发连接可能超过了系统限制
2. **连接建立排队**：当系统资源耗尽时，新连接需要等待
3. **部分网络路径较慢**：某些国家/城市的IP本身网络质量较差

**建议**：
- 先检查 `ulimit -n` 的值
- 如果小于1000，建议增加
- 或者改用分批并发，避免一次性创建太多连接


